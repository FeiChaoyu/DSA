哈希函数的设计

整型
小范围正整数直接使用
小范围负整数进行偏移        -100~100 → 0~200

大整数
身份证号  110108198512166666 → 11010819851216 6666
通常做法：取模比如，取后四位。等同于mod 10000

取后六位？等同于mod 1000000 → 110108198512 166666    分布不均匀

一个简单的解决办法：模一个素数  解决分布不均匀问题
http://planetmath.org/goodhashtableprimes

浮点数转换成整型处理

字符串转换成整型处理
166=1*10^2+6*10^1+6*10^0
code=c*26^3+o*26^2+d*26^1+e*26^0
code=c*B^3+o*B^2+d*B^1+e*B^0  B表示自己设置的基数，比如上面是26
hash(code)=(c*B^3+o*B^2+d*B^1+e*B^0)%M    M是素数
通过数学转换后，效率更高
hash(code)=((((c*B)+o)*B+d)*B+e)%M
为了防止整型溢出，可以如下转换
hash(code)=((((c%M)*B+o)%M*B+d)%M*B+e)%M

原则
1.一致性：如果a==b，则hash(a) == hash(b)
2.高效性：计算高效简便
3.均匀性：哈希值均匀分布

------------------------------
哈希表的链地址法

总共有M个地址
如果放入哈希表的元素为N
如果每个地址是链表：0(N/M)
如果每个地址是平衡树：0(log(N/M))
说好的0(1)呢?

和静态数组一样，固定地址空间是不合理的，需要resize
平均每个地址承载的元素多过一定程度，即扩容 N/M >= upperTol
平均每个地址承载的元素少过一定程度，即缩容 N/M < lowerTol

哈希表的复杂度分析：
对于哈希表来说，元素数从N增加到upperTol*N；地址空间增倍，每个操作在O(lowerTol) ~ O(upperTol)  平均复杂度 O(1)
缩容同理

----------
问题：
扩容M->2*M
扩容2*M不是素数
解决方法：http://planetmath.org/goodhashtableprimes

哈希表牺牲了顺序性，但是得到了性能的提高

其他的解决哈希冲突的方法:
开放地址法 Open Addressing
1.线性探测 遇到哈希冲突 +1 到下一个判断
2.平方探测 遇到哈希冲突 +1 +4 +9 +16
3.二次哈希 遇到哈希冲突 + hash2(key)

再哈希法 Rehashing
